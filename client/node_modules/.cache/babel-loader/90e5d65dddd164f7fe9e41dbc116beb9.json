{"ast":null,"code":"import { takeEvery, put, call, all } from 'redux-saga/effects';\nimport ShopActionTypes from \"./shop.types\";\nimport { convertCollectionSnapshotToMap, firestore } from \"../../firebase/firebase.utils\";\nimport { fetchCollectionsFailure, fetchCollectionsSuccess } from \"./shop.actions\";\nexport function* fetchCollectionsAsync() {\n  //using generator function //this replaces fetchCollectionsStartAsync function in shop.actions\n  // yield console.log('I am fired')\n  //this is similar to Async await function\n  try {\n    const collectionRef = firestore.collection('collections');\n    const snapShot = yield collectionRef.get(); // const collectionMap = convertCollectionSnapshotToMap(snapShot); //we can do it like this\n\n    const collectionMap = yield call(convertCollectionSnapshotToMap, snapShot); //but this way with yield and call, redux can cancel our request if we want, we can use takeLatest to only use action that fired latest// and call function is for informing redux-saga that the function inside of it is to run and it is a function\n\n    yield put(fetchCollectionsSuccess(collectionMap)); //put is exactly like dispatch in redux-thunk //inside the brackets go actions\n  } catch (errorMessage) {\n    yield put(fetchCollectionsFailure(errorMessage));\n  }\n}\nexport function* fetchCollectionsStart() {\n  //this function is for using in redux store // to use in redux component, we write redux actions with the same action type specified here, names doesn't necessarily need to match, only action types matters**// which we usually write in our actions file\n  yield takeEvery( //takeEvery use non-blocking calls // and if an action gets fired multiple times// this run every actions //but with takeLatest, it only run the latest action and cancels the first ones// it can cancel actions because of yields\n  ShopActionTypes.FETCH_COLLECTIONS_START, fetchCollectionsAsync);\n}\nexport function* shopSagas() {\n  yield all([call(fetchCollectionsStart)]);\n}","map":{"version":3,"sources":["/home/maxwell/Desktop/crown-clothings/client/src/redux/shop/shop.sagas.js"],"names":["takeEvery","put","call","all","ShopActionTypes","convertCollectionSnapshotToMap","firestore","fetchCollectionsFailure","fetchCollectionsSuccess","fetchCollectionsAsync","collectionRef","collection","snapShot","get","collectionMap","errorMessage","fetchCollectionsStart","FETCH_COLLECTIONS_START","shopSagas"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,GAApB,EAAyBC,IAAzB,EAA+BC,GAA/B,QAA0C,oBAA1C;AACA,OAAOC,eAAP,MAA4B,cAA5B;AACA,SAAQC,8BAAR,EAAwCC,SAAxC,QAAwD,+BAAxD;AACA,SAAQC,uBAAR,EAAiCC,uBAAjC,QAA+D,gBAA/D;AAEA,OAAO,UAAUC,qBAAV,GAAkC;AAAE;AACvC;AACA;AACA,MAAG;AACC,UAAMC,aAAa,GAAGJ,SAAS,CAACK,UAAV,CAAqB,aAArB,CAAtB;AACA,UAAMC,QAAQ,GAAG,MAAMF,aAAa,CAACG,GAAd,EAAvB,CAFD,CAGA;;AACC,UAAMC,aAAa,GAAE,MAAMZ,IAAI,CAACG,8BAAD,EAAiCO,QAAjC,CAA/B,CAJD,CAI2E;;AAC1E,UAAMX,GAAG,CAACO,uBAAuB,CAACM,aAAD,CAAxB,CAAT,CALD,CAKoD;AAEtD,GAPD,CAOC,OAAOC,YAAP,EAAqB;AAClB,UAAMd,GAAG,CAACM,uBAAuB,CAACQ,YAAD,CAAxB,CAAT;AACH;AACJ;AAED,OAAO,UAAUC,qBAAV,GAAkC;AAAE;AACvC,QAAMhB,SAAS,EAAE;AACbI,EAAAA,eAAe,CAACa,uBADL,EAEXR,qBAFW,CAAf;AAIH;AAED,OAAO,UAAUS,SAAV,GAAsB;AACzB,QAAMf,GAAG,CAAC,CACND,IAAI,CAACc,qBAAD,CADE,CAAD,CAAT;AAGH","sourcesContent":["import { takeEvery, put, call, all } from 'redux-saga/effects'\nimport ShopActionTypes from \"./shop.types\";\nimport {convertCollectionSnapshotToMap, firestore} from \"../../firebase/firebase.utils\";\nimport {fetchCollectionsFailure, fetchCollectionsSuccess} from \"./shop.actions\";\n\nexport function* fetchCollectionsAsync() { //using generator function //this replaces fetchCollectionsStartAsync function in shop.actions\n    // yield console.log('I am fired')\n    //this is similar to Async await function\n    try{\n        const collectionRef = firestore.collection('collections');\n        const snapShot = yield collectionRef.get();\n       // const collectionMap = convertCollectionSnapshotToMap(snapShot); //we can do it like this\n        const collectionMap =yield call(convertCollectionSnapshotToMap, snapShot);//but this way with yield and call, redux can cancel our request if we want, we can use takeLatest to only use action that fired latest// and call function is for informing redux-saga that the function inside of it is to run and it is a function\n        yield put(fetchCollectionsSuccess(collectionMap)); //put is exactly like dispatch in redux-thunk //inside the brackets go actions\n\n    }catch (errorMessage) {\n        yield put(fetchCollectionsFailure(errorMessage))\n    }\n}\n\nexport function* fetchCollectionsStart() { //this function is for using in redux store // to use in redux component, we write redux actions with the same action type specified here, names doesn't necessarily need to match, only action types matters**// which we usually write in our actions file\n    yield takeEvery( //takeEvery use non-blocking calls // and if an action gets fired multiple times// this run every actions //but with takeLatest, it only run the latest action and cancels the first ones// it can cancel actions because of yields\n        ShopActionTypes.FETCH_COLLECTIONS_START,\n        fetchCollectionsAsync\n    )\n}\n\nexport function* shopSagas() {\n    yield all([\n        call(fetchCollectionsStart)\n    ])\n}\n\n"]},"metadata":{},"sourceType":"module"}