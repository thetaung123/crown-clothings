{"ast":null,"code":"import { takeEvery, put, call } from 'redux-saga/effects';\nimport ShopActionTypes from \"./shop.types\";\nimport { convertCollectionSnapshotToMap, firestore } from \"../../firebase/firebase.utils\";\nimport { fetchCollectionsFailure, fetchCollectionsSuccess } from \"./shop.actions\";\nexport function* fetchCollectionsAsync() {\n  //using generator function //this replaces fetchCollectionsStartAsync function in shop.actions\n  // yield console.log('I am fired')\n  //this is similar to Async await function\n  try {\n    const collectionRef = firestore.collection('collections');\n    const snapShot = yield collectionRef.get(); // const collectionMap = convertCollectionSnapshotToMap(snapShot); //we can do it like this\n\n    const collectionMap = yield call(convertCollectionSnapshotToMap, snapShot); //but this way with yield and call, redux can cancel our request if we want, we can use takeLatest to only use action that fired latest// and call function is for informing redux-saga that the function inside of it is to run and it is a function\n\n    yield put(fetchCollectionsSuccess(collectionMap)); //put is exactly like dispatch in redux-thunk //inside the brackets go actions\n  } catch (errorMessage) {\n    yield put(fetchCollectionsFailure(errorMessage));\n  }\n}\nexport function* fetchCollectionsStart() {\n  //this function is for using in redux store // to use in redux component, we write redux actions with the same action type specified here, names doesn't necessarily need to match, only action types matters**// which we usually write in our actions file\n  yield takeEvery( //takeEvery use non-blocking calls // and if an action gets fired multiple times// this run every actions //but with takeLatest, it only run the latest action and cancels the first ones// it can cancel actions because of yields\n  ShopActionTypes.FETCH_COLLECTIONS_START, fetchCollectionsAsync);\n}","map":{"version":3,"sources":["/home/maxwell/Desktop/crown-clothings/src/redux/shop/shop.sagas.js"],"names":["takeEvery","put","call","ShopActionTypes","convertCollectionSnapshotToMap","firestore","fetchCollectionsFailure","fetchCollectionsSuccess","fetchCollectionsAsync","collectionRef","collection","snapShot","get","collectionMap","errorMessage","fetchCollectionsStart","FETCH_COLLECTIONS_START"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,GAApB,EAAyBC,IAAzB,QAAqC,oBAArC;AACA,OAAOC,eAAP,MAA4B,cAA5B;AACA,SAAQC,8BAAR,EAAwCC,SAAxC,QAAwD,+BAAxD;AACA,SAAQC,uBAAR,EAAiCC,uBAAjC,QAA+D,gBAA/D;AAEA,OAAO,UAAUC,qBAAV,GAAkC;AAAE;AACvC;AACA;AACA,MAAG;AACC,UAAMC,aAAa,GAAGJ,SAAS,CAACK,UAAV,CAAqB,aAArB,CAAtB;AACA,UAAMC,QAAQ,GAAG,MAAMF,aAAa,CAACG,GAAd,EAAvB,CAFD,CAGA;;AACC,UAAMC,aAAa,GAAE,MAAMX,IAAI,CAACE,8BAAD,EAAiCO,QAAjC,CAA/B,CAJD,CAI2E;;AAC1E,UAAMV,GAAG,CAACM,uBAAuB,CAACM,aAAD,CAAxB,CAAT,CALD,CAKoD;AAEtD,GAPD,CAOC,OAAOC,YAAP,EAAqB;AAClB,UAAMb,GAAG,CAACK,uBAAuB,CAACQ,YAAD,CAAxB,CAAT;AACH;AACJ;AAED,OAAO,UAAUC,qBAAV,GAAkC;AAAE;AACvC,QAAMf,SAAS,EAAE;AACbG,EAAAA,eAAe,CAACa,uBADL,EAEXR,qBAFW,CAAf;AAIH","sourcesContent":["import { takeEvery, put, call } from 'redux-saga/effects'\nimport ShopActionTypes from \"./shop.types\";\nimport {convertCollectionSnapshotToMap, firestore} from \"../../firebase/firebase.utils\";\nimport {fetchCollectionsFailure, fetchCollectionsSuccess} from \"./shop.actions\";\n\nexport function* fetchCollectionsAsync() { //using generator function //this replaces fetchCollectionsStartAsync function in shop.actions\n    // yield console.log('I am fired')\n    //this is similar to Async await function\n    try{\n        const collectionRef = firestore.collection('collections');\n        const snapShot = yield collectionRef.get();\n       // const collectionMap = convertCollectionSnapshotToMap(snapShot); //we can do it like this\n        const collectionMap =yield call(convertCollectionSnapshotToMap, snapShot);//but this way with yield and call, redux can cancel our request if we want, we can use takeLatest to only use action that fired latest// and call function is for informing redux-saga that the function inside of it is to run and it is a function\n        yield put(fetchCollectionsSuccess(collectionMap)); //put is exactly like dispatch in redux-thunk //inside the brackets go actions\n\n    }catch (errorMessage) {\n        yield put(fetchCollectionsFailure(errorMessage))\n    }\n}\n\nexport function* fetchCollectionsStart() { //this function is for using in redux store // to use in redux component, we write redux actions with the same action type specified here, names doesn't necessarily need to match, only action types matters**// which we usually write in our actions file\n    yield takeEvery( //takeEvery use non-blocking calls // and if an action gets fired multiple times// this run every actions //but with takeLatest, it only run the latest action and cancels the first ones// it can cancel actions because of yields\n        ShopActionTypes.FETCH_COLLECTIONS_START,\n        fetchCollectionsAsync\n    )\n}\n\n"]},"metadata":{},"sourceType":"module"}